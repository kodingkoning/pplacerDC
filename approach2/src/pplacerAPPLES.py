#!/usr/bin/python3
import dendropy
import script_executor
import tree_utils
import uuid
import os
import util
import math
import argparse
import shutil
import concurrent
import concurrent.futures

def run_program(args):
    tree = args.tree
    alignment = args.ref_msa
    query = args.query
    raxml_info_file = args.info
    maxPplacer = int(args.maxPplacer)
    nClades = int(args.numClades)
    numThreads = int(args.numThreads)
    bestTree = args.output
    verbose = bool(args.verbose)
    DEBUG = verbose
    timer = util.Timer()
    timer.tic("execution")
    timer.tic("setup")
    tmpdir = str(uuid.uuid4())
    os.mkdir(tmpdir)
    oldDir = os.getcwd()
    os.chdir(tmpdir)

    test_str = f"{tree}"
    tree = tree if (tree.startswith("/") or tree.startswith("~")) else f"{oldDir}/{tree}"
    alignment = alignment if (alignment.startswith("/") or alignment.startswith("~")) else f"{oldDir}/{alignment}"
    raxml_info_file = raxml_info_file if raxml_info_file.startswith("/") or raxml_info_file.startswith("~") else f"{oldDir}/{raxml_info_file}"

    backboneTree = tree_utils.read_tree(tree)

    applesPlacement = "apples.jplace"
    Tapples = f"result-{nClades}.tre"
    queryAlignment = "query.fa"
    # query.fa must contain only the alignment for the query sequence
    script_executor.generate_fasta_file_apples(backboneTree, query, alignment, queryAlignment)
    timer.toc("setup")
    
    timer.tic("apples")
    script_executor.run_apples(alignment, tree, queryAlignment, applesPlacement, numThreads)
    timer.toc("apples")
    script_executor.place_sequence_in_subtree(applesPlacement, Tapples)

    scores = [-math.inf for i in range(nClades+1)] # last position is apples

    scores[-1] = script_executor.score_raxml(Tapples, alignment)
    applesTree = tree_utils.read_tree(Tapples)

    queryNode = None
    for leaf in applesTree.leaf_nodes():
      if leaf.taxon.label == query:
        queryNode = leaf
        break
    assert queryNode, "Expected query node to be non null!"

    def execute_with_random_clade(item):
        threadIdx = item
        cladeNodes = tree_utils.sampleCompact(queryNode, maxPplacer)
        outputSubTree = f"clade-subtree-{threadIdx}.tre"
        subTree = backboneTree.extract_tree_with_taxa_labels(cladeNodes)
        subTree.write(file=open(outputSubTree, "w"), schema="newick")
        queryAlignment = f"query-{threadIdx}.fa"
        script_executor.generate_fasta_file(subTree, query, alignment, queryAlignment)
        placementOutput = f"pplacer-{threadIdx}.jplace"
        script_executor.run_pplacer(raxml_info_file, outputSubTree, queryAlignment, placementOutput)
        subTreeWithPlacement = f"subtree-with-placement-{threadIdx}.tre"
        script_executor.place_sequence_in_subtree(placementOutput, subTreeWithPlacement)
        resultTree = tree_utils.read_tree(subTreeWithPlacement)
        newbackboneTree = tree_utils.read_tree(tree)
        tree_utils.modify_backbone_tree_with_placement(resultTree, newbackboneTree, query)
        temporaryBackBoneTree = f"result-{threadIdx}.tre"
        newbackboneTree.write(file=open(temporaryBackBoneTree, "w"), schema="newick")
        scores[threadIdx] = script_executor.score_raxml(temporaryBackBoneTree, alignment)
        return
    timer.tic("Threaded region")
    #for thread in range(nClades):
    #    execute_with_random_clade(thread)
    with concurrent.futures.ThreadPoolExecutor(max_workers=numThreads) as executor:
        executor.map(execute_with_random_clade, range(nClades))

    timer.toc("Threaded region")

    # Do maxLoc reduction to find best tree
    bestOne = None
    maxScore = -math.inf
    for i, score in enumerate(scores):
      if score > maxScore:
        maxScore = score
        bestOne = f"result-{i}.tre"
        if i == len(scores)-1:
          print("Resultant tree was that generated by APPLES.")
    if DEBUG: print(f"Scores = {scores}")
    # move best on to old dir, remove old dir
    shutil.move(bestOne, bestTree if bestTree.startswith("/") or bestTree.startswith("~") else f"{oldDir}/{bestTree}")
    os.chdir(oldDir)
    shutil.rmtree(tmpdir)
    
    timer.toc("execution")
    timer.dump()

    return

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Place a query sequence into a backbone tree.')
    # optional args
    parser.add_argument('-j', '--numThreads', default=1, help='Number of threads (default: 1)')
    parser.add_argument('-m', '--maxPplacer', default=500, help='Maximum size of subtree to hand to pplacer')
    parser.add_argument('-n', '--numClades', default=1, help='Number of (random) clades to consider')
    parser.add_argument('-o', '--output', default='tree.tre', help='Resultant tree with placement')
    parser.add_argument('-v', '--verbose', default=False, help='Run in verbose mode')
    
    requiredNamed = parser.add_argument_group("required named arguments")
    
    # required args
    requiredNamed.add_argument('-s', '--info', help='RAxML v7 or v8 info file [NOT raxml-ng].', required=True)
    requiredNamed.add_argument('-t', '--tree', help='Input tree.', required=True)
    requiredNamed.add_argument('-q', '--query', help='Query taxa to place into tree.', required=True)
    requiredNamed.add_argument('-r', '--ref-msa', help='Reference MSA.', required=True)
    
    args = parser.parse_args()
    run_program(args)
